#!/bin/bash -e

#--

RELEASE_BRANCH_PREFIX="release/"
MAVEN_VERSION_POSTFIX="-SNAPSHOT"

RELEASE_PROPERTIES=release.properties

## e.g. 2.7
RELEASE_BRANCH_REGEXP='^'$RELEASE_BRANCH_PREFIX'[0-9]+\.[0-9]+$'
## e.g. 2.7.5
VERSION_REGEXP='^[0-9]+(\.[0-9]+){2}$'

CURR_VERSION=
NEXT_VERSION=
NEXT_BRANCH=

#--

#
usage() {
   cat <<EOF
usage: git release branch
   or: git release tag [-f] [-m <msg>]

    Simple release oriented workflow.

EOF
}

#
main() {
   cd_git_toplevel
   subcommand "$@"
}

#
subcommand() {
   case "$1" in
      branch)
         shift
         subcommand_branch "$@"
         ;;
      tag)
         shift
         subcommand_tag "$@"
         ;;
      -h | --help)
         usage
         exit 0
         ;;
      *)
         echo "error: Unknown subcommand: '$1'"
         usage
         exit 1
         ;;
   esac
}

# on master create a new release/x.y branch
subcommand_branch() {
   assert_master_branch
   assert_git_clean_work_tree

   set_curr_version
   set_next_version

   ask_next_version NEXT_VERSION "branch"

   git checkout -b ${RELEASE_BRANCH_PREFIX}${NEXT_BRANCH}

   update_version $CURR_VERSION
   git add $RELEASE_PROPERTIES
   git add -u
   git commit -m "$CURR_VERSION"

   git checkout master
   update_version $NEXT_VERSION $MAVEN_VERSION_POSTFIX
   git add $RELEASE_PROPERTIES
   git add -u
   git commit -m "${NEXT_VERSION}${MAVEN_VERSION_POSTFIX}"
}

# on release/x.y tag a new version
subcommand_tag() {
   local opts_spec="\
git release tag [-f] [-m <msg>]
--
m,message=msg tag message
f,force       replace the tag if exists"
   eval "$(echo "$opts_spec" | git rev-parse --parseopt -- "$@" || echo exit $?)"

   assert_release_branch
   assert_git_clean_work_tree

   set_curr_version
   set_next_version

   ask_next_version NEXT_VERSION "tag"

   git tag "$@" $CURR_VERSION

   update_version $NEXT_VERSION
   git add $RELEASE_PROPERTIES
   git add -u
   git commit -m "$NEXT_VERSION"
}

#
die() {
   echo "${0##*/}: $@ -- exit." >&2
   exit 1;
}

#
git_toplevel() {
   local _outvar="$1"
   local _toplevel=$(git rev-parse --show-toplevel 2> /dev/null)
   if [[ -z $_toplevel ]] || [[ ! -d $_toplevel ]]
   then
      die "git toplevel not found. Not a git repository (or any of the parent directories)"
   fi

   eval "$_outvar=\$_toplevel"
}

#
cd_git_toplevel() {
   local toplevel
   git_toplevel toplevel
   cd $toplevel
}

#
git_current_branch() {
   git symbolic-ref --short --quiet HEAD
}

#
on_master_branch() {
   [[ $(git_current_branch) == "master" ]]
}

#
assert_master_branch() {
   if ! on_master_branch
   then
      die "current branch must be master"
   fi
}

#
on_release_branch() {
   [[ $(git_current_branch) =~ $RELEASE_BRANCH_REGEXP ]]
}

#
assert_release_branch() {
   if ! on_release_branch
   then
      die "current branch must be release/x.y"
   fi
}

#
is_git_clean_work_tree () {
   git rev-parse --verify HEAD >/dev/null || return 1
   git update-index -q --ignore-submodules --refresh
   git diff-files --quiet --ignore-submodules || return 1
   git diff-index --cached --quiet --ignore-submodules HEAD -- || return 1
}

#
assert_git_clean_work_tree() {
   if ! is_git_clean_work_tree
   then
      die "found unstaged or uncommitted changes"
   fi
}

#
is_valid_version() {
   [[ $1 =~ $VERSION_REGEXP ]]
}

#
assert_valid_version() {
   local version="$1"

   if ! is_valid_version "$version"
   then
      die "not valid version: $version"
   fi
}

#
set_curr_version() {
   local version

   assert_release_properties

   . $RELEASE_PROPERTIES
   assert_valid_version $version

   CURR_VERSION=$version
}

#
set_next_version() {
   local split major minor patch

   split=(${CURR_VERSION//\./ })
   major=${split[0]}
   minor=${split[1]}
   patch=${split[2]}

   if on_master_branch
   then
      # e.g. 2.7
      NEXT_BRANCH="$major.$minor"

      # e.g. 2.7.0 -> 2.8.0
      NEXT_VERSION="$major.$((minor+1)).0"
   else
      # e.g. 2.7.3 -> 2.7.4
      NEXT_VERSION="$major.$minor.$((patch+1))"
   fi
}

#
function ask_next_version {
   local _outvar="$1"
   local subcommand="$2"
   local read_version _next_version

   if [[ $subcommand == "branch" ]]
   then
      echo "Create new release branch: '${RELEASE_BRANCH_PREFIX}${NEXT_BRANCH}'"
   else
      echo "Tag branch with version: $CURR_VERSION"
   fi

   read -e -p "and prepare '$(git_current_branch)' for future version: [$NEXT_VERSION] ?" read_version
   _next_version=${read_version:=$NEXT_VERSION}

   assert_valid_version $_next_version

   eval "$_outvar=\$_next_version"
}

#
assert_release_properties() {
   local version init_version read_version

   if [[ ! -f $RELEASE_PROPERTIES ]]
   then
      init_version=1.0.0
      read -e -p "$RELEASE_PROPERTIES file not found, create it with version [$init_version] ?" read_version
      version=${read_version:=$init_version}
      assert_valid_version $version

      update_release_properties $version
   fi
}

#
update_release_properties() {
   local version="$1"
   printf "# git-release generated file\nversion=%s\n" $version > $RELEASE_PROPERTIES
}

#
update_release_pom() {
   local version="$1"
   local postfix="$2"
   mvn -q versions:set -DgenerateBackupPoms=false -DnewVersion=${version}${postfix} versions:commit > /dev/null
}

#
update_version() {
   local version="$1"
   local postfix="$2"

   update_release_properties $version
   update_release_pom $version $postfix
}

main "$@"

